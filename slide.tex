\documentclass{beamer}
\usepackage{ctex, hyperref}
\usepackage[T1]{fontenc}

% other packages
\usepackage{latexsym,amsmath,xcolor,multicol,booktabs}
\usepackage{graphicx,pstricks,listings,stackengine}

\author{Yanqiao Chen}
\title{A brief introduction to Convolution Module in the Project}
% \subtitle{Paper1: SafeSec Tropos: Joint security and safety requirements elicitation}
\institute{Department of computer science and engineering, SUSTech}
\date{2025.12.21}
\usepackage{SUSTech}

% defs
\def\cmd#1{\texttt{\color{red}\footnotesize $\backslash$#1}}
\def\env#1{\texttt{\color{blue}\footnotesize #1}}
\definecolor{deepblue}{rgb}{0,0,0.5}
\definecolor{deepred}{rgb}{0.6,0,0}
\definecolor{deepgreen}{rgb}{0,0.5,0}
\definecolor{halfgray}{gray}{0.55}

\lstset{
    basicstyle=\ttfamily\small,
    keywordstyle=\bfseries\color{deepblue},
    emphstyle=\ttfamily\color{deepred},    % Custom highlighting style
    stringstyle=\color{deepgreen},
    numbers=left,
    numberstyle=\small\color{halfgray},
    rulesepcolor=\color{red!20!green!20!blue!20},
    frame=shadowbox,
}


\begin{document}

\kaishu
\begin{frame}
    \titlepage
    \begin{figure}[htbp]
        \begin{center}
            \includegraphics[scale = 0.16]{pic/LOGO.png}
        \end{center}
    \end{figure}
\end{frame}

% \begin{frame}
%     \tableofcontents[sectionstyle=show,subsectionstyle=show/shaded/hide,subsubsectionstyle=show/shaded/hide]
% \end{frame}


\section{卷积模块位置和接口}

\begin{frame}{卷积模块位置和接口}
    \scriptsize
    卷积模块位于计算模块（Compute Mode）的下一级，负责对输入的数据进行卷积操作。接口包含：clk, rst\_n, start, done，dim\_m, dim\_n, addr\_op1, addr\_op2, addr\_res（来自Compute Mode）, mem\_rd\_data（来自Memory Pool）, mem\_rd\_en, mem\_rd\_addr（读使能与读地址）, mem\_wr\_en, mem\_wr\_addr, mem\_wr\_data（写使能、写地址与写数据）。（图中只展示了与卷积模块相关的接口，详见项目文档）
    \begin{figure}[htbp]
        \begin{center}
            \includegraphics[scale = 0.3]{pic/2.png}
        \end{center}
    \end{figure}
\end{frame}

\section{卷积模块的设计与数据流}

\begin{frame}{卷积模块的设计与数据流}
    \scriptsize
    卷积模块设计为一个有限状态机（FSM），包含IDLE、INIT\_PIXEL、CHECK\_BOUND、READ\_A、WAIT\_A、READ\_K、WAIT\_K、S\_MAC、WRITE、NEXT\_PIXEL、DONE等状态。计算流程为，对于每一个位置，进入卷积核内部的状态循环，累加结果然后写入内存，然后继续计算下一个位置的卷积结果，直到到达矩阵最右下角。
    
    其中，我们通过计算模式用户选择的操作数1和操作数2的地址为起始，通过内部的偏移量计算出每次需要读取的数据的地址，从Memory Pool中读取数据进行计算，最后将结果写回Memory Pool。
    \begin{figure}[htbp]
        \begin{center}
            \includegraphics[scale = 0.3]{pic/3.png}
        \end{center}
    \end{figure}
\end{frame}

\begin{frame}{卷积模块的设计与数据流}
    \scriptsize
    具体来说，数据流的设计如下：
    \begin{itemize}
        \item 卷积模块读取计算模块所给予的两个操作数的起始地址，分别对应输入矩阵和卷积核矩阵。
        \item 通过$i,j$两个变量控制读取的位置，通过这两个变量计算块内的偏移，从而计算出每次需要读取的数据的地址。
        \item 读取的数据通过mem\_rd\_data接口传入卷积模块，进行乘加操作。通过累加器acc保存中间结果，然后在WRITE状态中通过mem\_wr\_data接口将结果写回Memory Pool。
    \end{itemize}
\end{frame}

\section{理论周期数分析}

\begin{frame}{理论周期数分析}
    \scriptsize
    根据所给矩阵大小$10\times 12$和卷积核大小$3\times 3$，计算出输出矩阵大小为$8\times 10$。每个输出位置需要进行$$3\times 3=9$$次乘加操作，单个位置所需要的周期数为：检查边界1周期，读取矩阵2周期，读取卷积核2周期，累加1周期，因此单个位置总共需要6周期。总共循环9次，计算得到单个位置需要81周期。其中，每次INIT需要消耗1周期，总共80周期，WRITE需要1周期，总共80周期，NEXT\_PIXEL需要1周期，总共80周期。（done和start共两周期，忽略不计）因此计算得到：
    $$
    81\times 80 + 80 + 80 + 80 = 6720
    $$
    周期。
\end{frame}

\section{实际测试时钟周期数}

\begin{frame}{实际测试时钟周期数}
    \scriptsize
实际经过测试，我们的周期数为5280周期，低于理论周期数6720周期。这可能是Vivado的综合优化实现的结果，减少了一些不必要的状态转换和等待时间，从而提高了整体的执行效率。
    \begin{figure}[htbp]
        \begin{center}
            \includegraphics[scale = 0.6]{pic/count.png}
        \end{center}
    \end{figure}
    其中最后一行为时钟周期数。
\end{frame}

\section{资源使用报告}

\begin{frame}{资源使用报告}
    \scriptsize
我们的综合资源使用报告如下：
    \begin{figure}[htbp]
        \begin{center}
            \includegraphics[scale = 0.3]{pic/util.png}
        \end{center}
    \end{figure}
    由上可见，我们的卷积模块使用LUT共210个，slice Register共107个，LUT主要用于逻辑实现。
\end{frame}


\section{遇到的问题与解决方案}

\begin{frame}{遇到的问题和解决方案}
    \scriptsize
    实际开发过程中，我们会遇到一些问题，例如如何存储计算结果、如何读取数据等。针对这些问题，我们的核心解决方案就是将结果写入内存，以方便后续的展示。我们通过地址-数据映射的方式，通过起始地址-块内偏移的方式，计算出每一次需要读取数据和写入数据的位置，以免读取数据发生错读和错写的问题。

    同时，我们在实际开发过程中，在COMPUTE MODE中为卷积模块定制了一个计算流程：首先选择需要卷积的矩阵，然后自动给出所有的$3\times 3$卷积核，随后开始计算。但是在开发过程中，由于计算模式的状态接近100个，我们会遇到由于数位截断导致状态重合的问题（这是由于早期开发状态的位宽较小的原因，例如5‘b100111和5’b000111重合）。我们通过仔细检查状态机的状态定义，增加状态位宽，最终解决了该问题。
\end{frame}

\end{document}